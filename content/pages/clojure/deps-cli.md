# Clojureプロジェクト管理の二大潮流：LeiningenとClojure CLIツールの包括的解析

## Part 1: Clojureツーリングの二つの世界：哲学的・歴史的背景

### 1.1. 序論：Javaの影からClojureのアイデンティティへ

Clojureは、2007年にRich Hickeyによって公開された、Java仮想マシン（JVM）上で動作するモダンなLisp方言です。その誕生当初、Clojure開発者は既存のJavaエコシステムのツール、すなわちMavenやAntなどを利用していました。これらのツールは強力でしたが、動的でインタラクティブな開発を特徴とするLisp言語にとって、必ずしも慣用的（idiomatic）ではありませんでした。

この状況を打開するために登場したのが、2009年後半にリリースされた**Leiningen**です。Leiningenは、Clojureのために特別に設計された最初の「バッテリー同梱（batteries-included）」ツールであり、プロジェクトのセットアップや自動化を「苦痛なく（painless）」行うことを目指しました。依存関係の管理、テストの実行、REPLの起動、デプロイ用アーティファクトの作成といった一般的なタスクを簡単なコマンドで実行できるようにし、Clojure開発者体験の確立において決定的な役割を果たしました。

それから数年が経ち、Clojureの言語設計思想をより深く反映したツール群が、Clojureコアチーム自身によって開発されました。それが、**Clojure CLI**、**`tools.deps`**、そして**`tools.build`**から成るエコシステムです。これは、Leiningenの統合的なアプローチとは対照的に、より小さく、コンポーザブル（構成可能）で、データ駆動なツールを目指すという哲学的な転換を意味していました。

本レポートでは、これら二つの主要なツールエコシステム、すなわちLeiningenとClojure CLIツール群を包括的に分析します。それぞれの歴史的背景、設計哲学、技術的詳細、そして一般的なワークフローを解き明かし、現代のClojure開発者が直面するツール選択の課題に対して、深く、かつ実践的な洞察を提供します。

### 1.2. 哲学的対立：「Easy」（Leiningen） vs. 「Simple」（Clojure CLI）

Clojureのツールエコシステムを理解する上で最も重要な概念は、Rich Hickeyの有名な講演「Simple Made Easy」で提示された「容易さ（Easy）」と「単純さ（Simple）」の区別です。この哲学的な対立軸は、LeiningenとClojure CLIの根本的な設計思想の違いを的確に捉えています。

#### Leiningenの「容易さ（Easy）」

Leiningenは「**Easy**」を体現しています。これは「身近であること」「少ない労力で始められること」を意味します。Mavenやnpmのような他の言語のビルドツールに慣れ親しんだ開発者にとって、`project.clj`という一つの設定ファイルにプロジェクト定義を記述し、`lein uberjar`や`lein test`といった直感的なコマンドを実行するだけで一般的なタスクが完了するLeiningenの作法は、非常に馴染みやすく感じられます。Leiningenは、内部で起こっている複雑な処理をユーザーから隠蔽し、宣言的な設定を通じて「よしなにやってくれる」のです。これにより、特にエコシステムへの新規参入者にとっての学習曲線は緩やかになります。

#### Clojure CLIの「単純さ（Simple）」

一方、Clojure CLIツール群は「**Simple**」を追求します。これは「複雑に絡み合っていないこと」「構成要素が独立していること」を意味します。このエコシステムは、意図的に責務が分割された小さなコンポーネントの集合体として設計されています。

* **`tools.deps`**: 依存関係の解決のみに責任を持つライブラリ。
* **`clojure` / `clj` コマンド**: `tools.deps`を利用してクラスパスを構築し、Clojureプロセスを起動するランチャー。
* **`tools.build`**: ビルドタスクを実行するための関数群を提供するライブラリ。

ユーザーは、これらの「単純な」部品を自ら組み合わせてワークフローを構築します。このアプローチは、Leiningenのように「すぐに使える」わけではないため、必ずしも「Easy」ではありません。初期設定にはより多くの理解が求められます。しかし、その結果として得られるシステムは、各部分の役割が明確で「絡み合っておらず（unconflated）」、何が起きているかが透明です。ユーザーは複雑さを隠蔽されるのではなく、直接的に管理するのです。

この設計思想の進化は、単なるツールセットの置き換え以上の意味を持ちます。それは、Clojureコミュニティとコアチームが、言語自体の核となる設計原則、すなわち「データ駆動」「コンポーザブルな部品」「単純さ」を、ソフトウェアをビルドするという問題そのものに適用した結果なのです。Clojure CLIエコシステムは、ある意味で、最もClojureらしい（idiomatic）プロジェクト管理の方法論と言えるでしょう。

## Part 2: Leiningen：永続する、バッテリー同梱のプロジェクト自動化ツール

Leiningenは長年にわたりClojureのデファクトスタンダードであり、今なお多くのプロジェクトで利用されている堅牢で機能豊富なツールです。その最大の特徴は、プロジェクトのライフサイクル全体を単一のツールで管理できる「バッテリー同梱」のアプローチにあります。

### 2.1. `project.clj`の解剖学：宣言的なプロジェクトマニフェスト

Leiningenプロジェクトの中心には、`project.clj`という名前のファイルが存在します。これは単なる設定ファイルではなく、`defproject`というClojureマクロによって定義される、プロジェクトそのものを表現するデータ構造です。

`project.clj`は、プロジェクトに関するあらゆる情報を宣言的に記述する場所です。以下は、その中で特に重要なトップレベルのキーです。

* `defproject my-app "0.1.0-SNAPSHOT"`: プロジェクト名（`groupId/artifactId`形式）とバージョンを定義します。
* `:description "An example project."`: プロジェクトの簡単な説明。ライブラリ検索などで表示されます。
* `:url "http://example.com/FIXME"`: プロジェクトのウェブサイトURL。
* `:license {:name "Eclipse Public License" :url "http://www.eclipse.org/legal/epl-v10.html"}`: プロジェクトのライセンス情報。
* `:dependencies [[org.clojure/clojure "1.11.1"][ring/ring-core "1.9.5"]]`: プロジェクトが依存するライブラリのリスト。
* `:plugins [[lein-ring "0.12.5"]]`: Leiningenの機能を拡張するプラグインのリスト。
* `:main ^:skip-aot my-app.core`: `lein run`で実行されるメインの名前空間。`:aot`（Ahead-Of-Timeコンパイル）の制御もここで行います。
* `:profiles {:dev {:dependencies [[javax.servlet/servlet-api "2.5"]]} :uberjar {:aot :all}}`: 環境ごとに設定を切り替えるためのプロファイル。

Leiningenは、この`project.clj`ファイルを読み込むことで、依存関係の解決からテスト、ビルド、デプロイに至るまで、プロジェクトのライフサイクル全体を自動的に構成します。

### 2.2. 依存関係の管理：座標、リポジトリ、そして「Nearest-Wins」

Leiningenの依存関係管理は、Javaエコシステムの標準であるMavenの仕組みに基づいています。

* **依存関係の指定**: 依存関係は、`:dependencies`キーにベクター形式で指定します。各要素は `[groupId/artifactId "version"]` という形式のMaven座標です。
* **リポジトリ**: デフォルトで、Leiningenは二大Mavenリポジトリである**Maven Central**と**Clojars**（Clojureライブラリ専用）を参照します。`:repositories`キーを使って、プライベートリポジトリなどを追加することも可能です。

#### 深掘り：「Nearest-Wins」競合解決戦略

複数の依存関係が同じライブラリの異なるバージョンを要求した場合、バージョン競合が発生します。Leiningenは、Mavenから継承した「**Nearest-Wins**」（最近接優先）戦略を用いてこの競合を解決します。

* **仕組み**: この戦略では、プロジェクトのルート（`project.clj`）から見て、依存関係ツリーの中で最も「近い」階層にある依存関係のバージョンが採用されます。
* **実践的な意味**: この挙動により、推移的依存関係（依存関係の依存関係）のバージョンを上書きするのが非常に「容易」になります。もし、ライブラリAが`log4j`のバージョン1.2を、ライブラリBがバージョン1.3を要求している場合、`project.clj`の`:dependencies`に直接`[log4j/log4j "1.4"]`と記述するだけで、バージョン1.4が強制的に使用されます。なぜなら、直接の依存関係はツリーの最も近い階層（深さ1）にあるからです。
* **デバッグ**: この戦略は便利な一方で、意図せず古いバージョンのライブラリが使われてしまう原因にもなり得ます。どの依存関係がどのバージョンを選択させたのかを調査するためには、`lein deps :tree`コマンドが不可欠です。このコマンドは、依存関係ツリー全体を可視化し、競合が発生している箇所を特定するのに役立ちます。

### 2.3. コアタスクとコマンド：開発者のワークフロー

Leiningenは、日常的な開発タスクのほとんどを、`lein`プレフィックスを持つシンプルなコマンドで実行できます。

* `lein new [template] <name>`: テンプレートから新しいプロジェクトの雛形を生成します。`lein new app my-stuff`のように使います。
* `lein repl`: `project.clj`で定義された全ての依存関係を含む、完全に設定済みのREPLを起動します。インタラクティブな開発の出発点です。
* `lein test`: `test`ディレクトリに配置されたプロジェクトのテストコードを実行します。
* `lein run`: `project.clj`の`:main`キーで指定された名前空間の`-main`関数を実行します。
* `lein jar` / `lein uberjar`: プロジェクトをライブラリ用のJARファイル、または全ての依存関係を含んだ自己完結型の実行可能「uberjar」としてパッケージングします。特に`lein uberjar`は、Leiningenの「ただ動く（just works）」機能の代表例として高く評価されています。
* `lein clean`: `target`ディレクトリに生成されたビルド成果物を削除します。
* `lein deps`: 手動で依存関係をダウンロードしたり、`lein deps :tree`で依存関係ツリーを分析したりします。

### 2.4. プラグインエコシステムと環境プロファイル

Leiningenの真の力は、その拡張性と柔軟性にあります。

* **プラグイン**: `:plugins`キーにコミュニティ製のプラグインを指定することで、Leiningenの機能を拡張できます。例えば、ClojureScriptのコンパイルには`lein-cljsbuild`、ウェブアプリケーションの実行には`lein-ring`といったプラグインが広く使われています。
* **プロファイル**: `:profiles`キーは、特定の環境（例：開発用の`:dev`、テスト用の`:test`、本番ビルド用の`:prod`）でのみ有効になる設定を定義するために使われます。これにより、開発時にのみ必要なツール（デバッガや追加のREPLライブラリなど）を本番の成果物から除外したり、環境ごとに異なる設定を適用したりすることが可能になります。
* **`checkouts`ディレクトリ**: プロジェクトのルートに`checkouts`というディレクトリを作成し、その中に依存ライブラリのソースコードへのシンボリックリンクを置くと、LeiningenはそのライブラリをJARファイルからではなく、ローカルのソースコードから直接読み込むようになります。これは、複数のプロジェクトを並行して開発する際に非常に強力な機能です。

## Part 3: Clojure CLIエコシステム：コンポーザブルな、アラカルト方式のアプローチ

Clojure CLIエコシステムは、Leiningenの統合的なアプローチとは対照的に、責務が明確に分離された小さなツール群を組み合わせて利用することを前提としています。これは、より柔軟で透明性が高く、Clojureの言語哲学に根ざしたアプローチです。

### 3.1. `deps.edn`：データとしてのプロジェクト

Clojure CLIプロジェクトの中心となるのは`deps.edn`ファイルです。Leiningenの`project.clj`がClojureマクロであるのに対し、`deps.edn`は純粋な**EDN (Extensible Data Notation)** データ、具体的にはマップ（ハッシュマップ）です。これにより、プログラムによる生成や操作が容易になります。

`deps.edn`の主要なトップレベルキーは以下の通りです [1]。

* `:paths`: ソースコードが置かれているディレクトリのパスを指定するベクター。デフォルトは`["src"]`です。
* `:deps`: プロジェクトの依存関係を、ライブラリ名をキー、座標を値とするマップで定義します。
* `:aliases`: 特定の状況下でのみ適用される設定の集合を、エイリアス名をキーとするマップで定義します。これがCLIワークフローの心臓部です。
* `:mvn/repos`: ClojarsやMaven Central以外のカスタムMavenリポジトリを指定します。

このエコシステムの強力な特徴の一つに、**設定のカスケード**があります。`clojure`コマンド実行時、以下の`deps.edn`ファイルが順番にマージされ、最終的な設定が構築されます。

1.  Clojure CLIインストール時のデフォルト設定（Clojure本体への依存など）
2.  ユーザーのホームディレクトリにある設定 (`~/.clojure/deps.edn`)
3.  プロジェクトのルートディレクトリにある設定 (`./deps.edn`)
4.  コマンドラインで直接指定された設定

この階層構造により、全プロジェクトで共通のツール（REPL拡張など）をユーザーレベルで定義しつつ、プロジェクト固有の依存関係をプロジェクトレベルで管理するといった、柔軟な設定管理が可能になります [2]。

### 3.2. 依存関係管理の再創造：Git Deps、Local Roots、そして「Newest-Wins」

`tools.deps`は、従来のMaven中心の依存関係管理を大きく拡張し、より柔軟な選択肢を提供します。

* **ファーストクラスのGit依存**: `tools.deps`の最も革新的な機能の一つが、Gitリポジトリに直接依存できることです。`:git/sha`にコミットSHAを指定することで、Mavenリポジトリにリリースされていないブランチや特定のコミットに直接依存できます。これは、ライブラリのフォークを試したり、最新の開発版を利用したりする際に絶大な威力を発揮します [1]。
    ```clojure
    {io.github.clojure/tools.build
     {:git/url "[https://github.com/clojure/tools.build.git](https://github.com/clojure/tools.build.git)"
      :git/sha "ba1a2bf421838802e7bdefc541b41f57582e53b6"}}
    ```
* **ローカルルート**: `:local/root`キーを使うと、ローカルファイルシステム上の別のディレクトリを依存関係として扱うことができます。これは、複数のサブプロジェクトから成るモノレポ（monorepo）開発において、Leiningenの`checkouts`よりもシンプルで強力な仕組みを提供します [3]。
    ```clojure
    {my-company/my-library {:local/root "../my-library"}}
    ```
* **Maven依存**: 従来通りのMavenリポジトリからの依存も、もちろんサポートされています。`:mvn/version`キーでバージョンを指定します [1]。
    ```clojure
    {ring/ring-core {:mvn/version "1.9.5"}}
    ```

#### 深掘り：「Newest-Wins」競合解決戦略

`tools.deps`は、Leiningenとは異なるバージョン競合解決戦略、「**Newest-Wins**」（最新版優先）を採用しています。

* **仕組み**: 依存関係ツリーの中に同じライブラリの異なるバージョンが存在した場合、`tools.deps`は常に**最も新しいバージョン**を選択します。
* **実践的な意味**: この戦略は、意図せず古いバージョンの推移的依存関係が使われてしまうリスクを低減するため、一般的にLeiningenの「Nearest-Wins」よりも安全なデフォルトであると考えられています。一方で、特定のバージョンを意図的にダウングレードしたい場合などには、より明示的な操作が必要になります。その場合は、通常、エイリアス内の`:override-deps`キーを使ってバージョンを上書きします [1]。
* **デバッグ**: 依存関係ツリーの分析には、`clj -X:deps tree`コマンドを使用します。これは`lein deps :tree`に相当する機能を提供し、どのバージョンがなぜ選ばれたのかを詳細に表示します [3]。

### 3.3. `clojure`コマンド：実行オプションをマスターする

Clojure CLIのコマンドラインフラグは、初学者にとって混乱の元となりがちですが、それぞれの役割を理解することが、このエコシステムを使いこなす鍵となります。

* **デフォルト（フラグなし）**: `clj`または`clojure`を引数なしで実行すると、基本的なREPLが起動します。
* **`-M` (または `-A`)**: `clojure.main`を介してプログラムを実行するための伝統的な方法です。`-m my-app.core`のように、実行したい名前空間を指定すると、その名前空間の`-main`関数が呼び出されます。引数は、コマンドライン上で`clojure.main`に渡される位置に基づいた文字列となります。アプリケーションの実行や、特定のライブラリ（例：REPLツール）をメインのエントリポイントとして起動するのに適しています [2]。
* **`-X`**: 特定の修飾済み関数を直接実行するための、よりモダンでデータ駆動な方法です。`-X my-app.tasks/build`のように関数を指定し、その後の引数は全て単一のEDNマップとしてその関数に渡されます。ツールやビルドタスクのように、設定をデータとして受け取る関数を実行するのに理想的です [2]。
* **`-T`**: `-X`の特殊なバリエーションで、「ツール」を実行するために設計されています。`-T`で実行すると、プロジェクトの依存関係（`:deps`）とパス（`:paths`）は無視され、クラスパスにはカレントディレクトリ（`.`）と、指定されたエイリアス内で定義された依存関係およびパスのみが含まれます。これにより、プロジェクトの依存関係とツールの依存関係が衝突するのを防ぎます。`tools.build`タスクは、この`-T`フラグを使って実行するのが標準的な方法です。
* **`-P`**: 「準備（prepare）」フラグです。これを付けると、クラスパスの計算と依存関係のダウンロードは行われますが、実際のプログラムは実行されません。CI環境やコンテナビルドにおいて、依存関係のレイヤーをキャッシュするために非常に有用です。

### 3.4. `tools.build`：あなたのビルドはClojureプログラムである

`tools.build`の根底にある哲学は、「**ビルドは宣言的な設定ではなく、プログラムである**」というものです。開発者は、使い慣れたClojure言語を使ってビルドロジックを記述し、`tools.build`はその際に共通して必要となる関数群を提供するライブラリとして機能します。

* **セットアップ**: `tools.build`を利用するには、まずプロジェクトのルートに`build.clj`というファイルを作成します。そして`deps.edn`に、`tools.build`自体を依存関係として含む`:build`のようなエイリアスを定義します [4]。
    ```clojure
    ;; deps.edn
    {:aliases
     {:build {:deps {io.github.clojure/tools.build {:mvn/version "0.10.9"}}
              :ns-default build}}}
    ```
* **`tools.build.api`の主要関数**: `build.clj`の中では、`clojure.tools.build.api`名前空間（通常は`b`というエイリアスで`require`される）の関数を組み合わせてビルドタスクを構築します。よく使われる関数には以下のようなものがあります。
    * `b/create-basis`: プロジェクトの`deps.edn`に基づいて依存関係情報を解決し、「basis」オブジェクトを生成します。
    * `b/copy-dir`: ソースディレクトリからターゲットディレクトリへファイルをコピーします。
    * `b/compile-clj`: ClojureソースコードをJavaバイトコードにコンパイルします。
    * `b/write-pom`: basis情報から`pom.xml`ファイルを生成します。
    * `b/jar`: ライブラリ用のJARファイルを生成します。
    * `b/uber`: 全ての依存関係を含む実行可能なUber JARを生成します。

* **`uberjar`タスクの例**: 以下は、`build.clj`に記述するシンプルな`uberjar`タスクの例です。複数のAPI関数を組み合わせて、クリーン、コピー、コンパイル、パッケージングという一連の処理を実現していることがわかります [4]。
    ```clojure
    ;; build.clj
    (ns build
      (:require [clojure.tools.build.api :as b]))

    (def lib 'my-app/my-app)
    (def version "0.1.0")
    (def class-dir "target/classes")
    (def basis (b/create-basis {:project "deps.edn"}))
    (def uber-file (format "target/%s-%s-standalone.jar" (name lib) version))

    (defn clean [_]
      (b/delete {:path "target"}))

    (defn uber [_]
      (clean nil)
      (b/copy-dir {:src-dirs ["src" "resources"]
                   :target-dir class-dir})
      (b/compile-clj {:basis basis
                      :src-dirs ["src"]
                      :class-dir class-dir})
      (b/uber {:class-dir class-dir
               :uber-file uber-file
               :basis basis
               :main 'my-app.core}))
    ```
    このタスクは `clj -T:build uber` というコマンドで実行します。

### 3.5. ワークフローの組み立て：エイリアスとコミュニティツールの力

Clojure CLIのワークフローは、**エイリアス**を基盤として構築されます。エイリアスは、特定のタスクを実行するための環境を定義する、名前付きの設定セットです。

* **エイリアスの構成要素**: エイリアスマップの中では、以下のようなキーを使って設定をカスタマイズします [1]。
    * `:extra-deps`: 追加の依存関係（例：テストランナー、開発ツール）。
    * `:extra-paths`: 追加のソースパス（例：`"test"`ディレクトリ）。
    * `:jvm-opts`: JVMオプション（例：メモリ設定）。
    * `:exec-fn`: `-X`で実行するデフォルトの関数。
    * `:main-opts`: `-M`で実行する際の引数。

* **実践例（`practical.li`より）**: テストを実行するためのエイリアスを定義する典型的な例です。`test`ディレクトリをクラスパスに追加し、テストランナーライブラリ（例：Kaocha）を依存関係に加え、実行関数を指定します [3]。
    ```clojure
    ;; deps.edn
    {:aliases
     {:test {:extra-paths ["test"]
             :extra-deps {lambdaisland/kaocha {:mvn/version "1.87.1366"}}
             :exec-fn kaocha.runner/exec-fn}}}
    ```
    このエイリアスは `clj -X:test` で実行できます。

* **コミュニティツール**: Leiningenが内蔵していた機能の多くは、CLIエコシステムでは独立したコミュニティツールとして提供されています。例えば、プロジェクトの雛形作成には`deps-new` や`neil` が使われます。これらのツール自体も、`-T`フラグで実行されるClojureプログラムです。この「小さなツールの組み合わせ」というアプローチこそが、CLIエコシステムの哲学を象徴しています。

## Part 4: 直接対決：現代の開発者のための比較分析

LeiningenとClojure CLI、二つのエコシステムはそれぞれ異なる哲学と強みを持ちます。ここでは、開発者が日常的に行うタスクを通じて、両者を直接比較します。

### 4.1. テーブル：共通タスクのコマンドライン等価性

以下の表は、一般的な開発タスクをLeiningenとClojure CLIでどのように実行するかを比較したものです。CLIのコマンドがより長く、冗長に見えるかもしれませんが、それは意図的な設計です。CLIのコマンドは、*何*を（`-X`経由の関数か、`-T`経由のツールか）、*どの設定*で（どのエイリアスを使って）実行するのかを明示的に強制します。この明示性により、コマンド自体が自己文書化され、Leiningenの振る舞いを時に不透明にする「魔法」のような部分が減少します。

| タスク内容 | Leiningen コマンド | Clojure CLI 等価コマンド | 哲学/備考 |
| :--- | :--- | :--- | :--- |
| **新規アプリ作成** | `lein new app my-app` | `clj -T:new app :name my-org/my-app` | Leiningenは内蔵タスク。CLIは外部ツール(`deps-new`など)を`-T`で実行。 |
| **REPL起動** | `lein repl` | `clj` (または `clj -M:repl/rebel` など) | CLIは基本REPLを起動。リッチなREPLはエイリアスで定義。 |
| **テスト実行** | `lein test` | `clj -X:test` | Leiningenは規約ベース。CLIは`:test`エイリアスで定義された関数を`-X`で実行。 |
| **アプリ実行** | `lein run -m my-app.core` | `clj -M -m my-app.core` | `-M`フラグの利用法は両者で類似。メイン関数を実行する。 |
| **Uber JAR作成** | `lein uberjar` | `clj -T:build uber` | Leiningenはワンコマンドの宣言的タスク。CLIは`build.clj`内の`uber`関数を`-T`で実行。 |
| **依存関係ツリー表示** | `lein deps :tree` | `clj -X:deps tree` | CLIは組み込みの`:deps`エイリアス内のツールを`-X`で実行。 |

### 4.2. プロジェクトの雛形作成：`lein new` vs. コミュニティツール

* **Leiningen**: `lein new`は、成熟したテンプレートシステムを内蔵しており、コミュニティによって多種多様なテンプレートが提供されています。これはツールに統合された、一貫性のある体験を提供します。
* **Clojure CLI**: CLIの世界では、雛形作成は外部ツールに委ねられています。初期にはLeiningenのテンプレートを利用できる`clj-new` が、最近ではよりモダンな`deps-new` が使われています。これは、コアツールは最小限に保ち、特定の機能はコミュニティが提供する独立したツールに任せるというCLIの哲学を明確に示しています。

### 4.3. 成果物のビルド：`lein uberjar` vs. `tools.build`の深掘り

アプリケーションのデプロイに不可欠なUber JARの作成は、両ツールの思想の違いが最も顕著に現れる領域の一つです。

* **`lein uberjar`**: これは、Leiningenの「Easy」アプローチの象徴です。ほとんどの場合、`project.clj`に`:main`と`:aot`を設定するだけで、`lein uberjar`という単一のコマンドが期待通りに動作します。設定より規約（Convention over Configuration）を重視し、95%の一般的なユースケースを最小限の手間で解決します。
* **`tools.build`**: こちらは、`build.clj`というビルドスクリプトの記述を要求します。これは初期投資としては手間がかかりますが、無限の柔軟性を提供します。ビルドプロセスは単なるClojureプログラムであるため、条件分岐、ロギング、外部APIとの連携、環境変数に基づいた動的な設定変更など、想像しうるあらゆるカスタムロジックを自由に組み込むことができます。

この選択は、どちらが絶対的に「優れている」かという問題ではありません。プロジェクトが直面する**複雑性のレベル**に応じたトレードオフです。シンプルなウェブアプリケーションであれば、Leiningenの規約の力が最大限に活かされるでしょう。一方、複数の成果物を生成したり、複雑なCI/CDパイプラインと連携したりする必要がある大規模なモノレポでは、`tools.build`が提供する完全なプログラム的制御が不可欠となります。

### 4.4. 拡張性：プラグイン vs. `build.clj`

* **Leiningenプラグイン**: Leiningenのプラグインは強力ですが、プロジェクトのコードとは別に、プラグイン開発特有の知識や作法が求められます。新しいタスクを追加するための「儀式」が多く、気軽に拡張するのは難しいと感じられることもあります。
* **`build.clj`**: CLIエコシステムでは、カスタムタスクは単に`build.clj`ファイル内に定義されたClojure関数です。これにより、ビルドロジックとプロジェクトの主要言語・ツールセットが統一され、チームの誰もがビルドプロセスを理解し、修正することが容易になります。

## Part 5: 必須設定：Clojure開発者のためのランキングガイド

このセクションでは、ユーザーの要求に応え、Clojure開発者が習得すべき最も重要な設定項目をランキング形式で提示します。

### 5.1. `deps.edn`ユーザー向け：エイリアスをマスターする

Clojure CLIの世界では、**エイリアスが設定とワークフローの基本単位**です。Leiningenが多くのトップレベルキーで設定を分散させるのに対し、CLIではテスト、ビルド、開発ツールの実行といったほぼ全てのカスタマイズが`:aliases`マップの中で行われます。したがって、エイリアス内で利用可能なキーを習得することが、CLIを使いこなすための最重要スキルとなります。

**テーブル：優先度別 `deps.edn` エイリアスキー**

| ランク | キー | 目的 | 一般的なユースケース |
| :---: | :--- | :--- | :--- |
| **1** | `:extra-paths`<br>`:extra-deps` | クラスパスにソース/リソースディレクトリやライブラリを追加する。 | テスト用の`"test"`ディレクトリや、`kaocha`のようなテストランナー、`rebel-readline`のような開発ツールを追加する。 |
| **2** | `:exec-fn`<br>`:exec-args` | `-X`で実行される関数とそのデフォルト引数を定義する。 | テストランナーやビルドタスクなど、実行可能なタスクを定義する。 |
| **3** | `:jvm-opts`<br>`:main-opts` | JVMオプションや`-main`関数への引数を指定する。 | メモリ割り当て(`-Xmx`)の設定や、アプリケーションのメイン関数を実行する。 |
| **4** | `:override-deps`<br>`:replace-deps` | 依存関係のバージョンを強制的に上書きしたり、依存関係全体を置き換えたりする。 | 依存関係の競合解決や、`-T`を使ったツール実行時のクラスパス分離。 |
| **5** | `:ns-default`<br>`:ns-aliases` | コマンドラインからの関数呼び出しを簡略化する。 | `-X build`のように、名前空間を省略して関数を実行できるようにする。 |

**ランキングの正当性:**
1.  **Priority 1 (`:extra-paths`, `:extra-deps`)**: これらはクラスパスを操作するための最も基本的な構成要素であり、テスト環境の構築や開発ツールの導入など、ほぼ全てのエイリアスで利用されます。
2.  **Priority 2 (`:exec-fn`, `:exec-args`)**: `-X`によるデータ駆動なタスク実行の核となるキーです。テスト実行やビルドなど、何らかの自動化タスクを定義する際には必須です。
3.  **Priority 3 (`:jvm-opts`, `:main-opts`)**: ランタイム環境の微調整や、伝統的な`-main`を持つアプリケーションを実行するために不可欠です。
4.  **Priority 4 (`:override-deps`, `:replace-deps`)**: 日常的に使うことは少ないかもしれませんが、複雑な依存関係の問題を解決したり、`-T`でツールを安全に実行したりするためには極めて重要です。
5.  **Priority 5 (`:ns-default`, `:ns-aliases`)**: これらは主に関数呼び出しの利便性を高めるためのもので、必須ではありませんが、ワークフローをスムーズにします。

### 5.2. `Leiningen`ユーザー向け：`project.clj`をマスターする

Leiningenの世界では、`project.clj`内の様々なキーを理解することがプロジェクトを制御する鍵となります。

**テーブル：優先度別 `project.clj` キー**

| ランク | キー | 目的 | 一般的なユースケース |
| :---: | :--- | :--- | :--- |
| **1** | `:dependencies` | プロジェクトが依存するライブラリを宣言する。 | `[ring/ring-core "1.9.5"]`のようなライブラリを追加する。 |
| **2** | `:profiles` | 環境（dev, test, prodなど）ごとに設定を切り替える。 | 開発時にのみ`lein-figwheel`を有効にしたり、本番ビルドでAOTコンパイルを有効にしたりする。 |
| **3** | `:plugins` | Leiningenの機能を拡張するプラグインを追加する。 | ClojureScriptプロジェクトのために`[lein-cljsbuild "1.1.8"]`を追加する。 |
| **4** | `:main`<br>`:aot` | 実行可能なアプリケーションのエントリポイントとAOTコンパイルの対象を指定する。 | `lein run`の挙動を定義し、Uber JAR作成時のコンパイルを制御する。 |
| **5** | `:repositories`<br>`:deploy-repositories` | 標準以外のMavenリポジトリを指定したり、ライブラリのデプロイ先を定義したりする。 | 社内のプライベートMavenリポジトリへの接続や、Clojarsへのライブラリ公開。 |

**ランキングの正当性:**
1.  **Priority 1 (`:dependencies`)**: プロジェクトの根幹をなす、最も基本的な設定です。
2.  **Priority 2 (`:profiles`)**: 開発用依存関係を本番成果物から分離するなど、自明でないプロジェクトでは必須の機能です。現実世界の開発において極めて重要です。
3.  **Priority 3 (`:plugins`)**: Leiningenの「バッテリー同梱」思想を支える重要な拡張メカニズムです。特にClojureScript開発などでは不可欠です。
4.  **Priority 4 (`:main`, `:aot`)**: ライブラリではなく、実行可能なアプリケーションを作成する場合には必須のキーです。
5.  **Priority 5 (`:repositories`, `:deploy-repositories`)**: Clojarsに公開されているライブラリのみを使用するアプリケーション開発では不要ですが、ライブラリを公開したり、プライベートリポジトリを利用したりする際には必要になります。

## Part 6: 結論：今日そして未来のためのツーリング戦略の選択

Clojureの二つの主要なツールエコシステム、LeiningenとClojure CLIは、それぞれが異なる哲学に基づき、異なる強みを持っています。どちらか一方が絶対的に優れているわけではなく、プロジェクトの性質やチームの思想に応じて最適なツールを選択することが重要です。

### 6.1. 強みと弱みの要約

| 側面 | Leiningen | Clojure CLI エコシステム |
| :--- | :--- | :--- |
| **哲学** | バッテリー同梱、設定より規約 (Easy) | 小さなツールの組み合わせ、コンポーザブル (Simple) |
| **学習曲線** | 緩やか。他のビルドツールと似ているため馴染みやすい。 | やや急。複数のツールと概念の理解が必要。 |
| **柔軟性・拡張性** | プラグイン機構により高い拡張性を持つが、カスタムタスクの作成はやや煩雑。 | 非常に高い。ビルドはClojureプログラムそのものであり、無限の柔軟性を持つ。 |
| **依存関係管理** | Mavenベース。Git依存は直接サポートされない。競合解決は「Nearest-Wins」。 | Git依存、ローカル依存をファーストクラスでサポート。競合解決は「Newest-Wins」。 |
| **プロジェクト設定** | `project.clj`という単一のマクロで宣言的に行う。 | `deps.edn`という純粋なデータで定義。エイリアスが中心。 |
| **コミュニティと将来性** | 成熟し安定しているが、新規開発の勢いはCLI側に移行。 | Clojureコアチームが主導し、活発に開発が継続。採用が増加傾向。 |

### 6.2. ガイダンス：どちらのツールをいつ使うべきか

* **Leiningenを選択すべき場合:**
    * Clojureエコシステムの初心者である場合。
    * 複雑なビルド要件のない、標準的なWebアプリケーションやライブラリを構築する場合。
    * チームが設定よりも規約を好み、「バッテリー同梱」の体験を重視する場合。
    * 既存のLeiningenプロジェクトをメンテナンスする場合。

* **Clojure CLIを選択すべき場合:**
    * モノレポのような複雑なプロジェクト構造を持つ場合。
    * ビルドプロセスをプログラムで完全に制御する必要がある場合。
    * Gitリポジトリに直接依存したい場合。
    * 「小さく、単純で、コンポーザブルな部品」というClojureの設計哲学に強く共感する場合。
    * 新規プロジェクトを開始し、将来にわたってClojureの進化に追随したい場合。

### 6.3. 移行戦略

LeiningenからClojure CLIへの移行を検討する場合、いくつかのアプローチがあります。

* **ブリッジツール**: `lein-tools-deps`のようなプラグインを使えば、Leiningenプロジェクト内で`deps.edn`の依存関係解決を利用できますが、これらのツールはもはや活発にメンテナンスされていない可能性があります。
* **自動変換ツール**: `lein2deps`のようなツールは、`project.clj`を`deps.edn`に自動変換するのに役立ちます。
* **推奨されるパス**: 最も学習効果が高いのは、手動での移行です。`project.clj`の各キーが`deps.edn`のどのエイリアス設定に対応するのかを一つ一つマッピングしていくプロセスを通じて、新しいエコシステムの仕組みを深く理解することができます。これは、単なるツールの乗り換えではなく、思考様式の転換を促します。

### 6.4. Clojureツーリングの未来：コミュニティの動向と公式の方向性

Clojureコミュニティの動向は明確です。State of Clojureの年次調査によれば、Clojure CLIの採用は着実に増加し、Leiningenの利用率は相対的に低下しています。2023年の調査では、Leiningenの利用率が60%、CLIが70%と大きな重複が見られましたが、2024年の調査結果では、**CLIの利用率が76%を超え、Leiningenは52%未満に低下**しており、移行が加速していることが示されています。

このトレンドは、Clojureのコアツール（`clj`, `tools.deps`, `tools.build`）がコアチームによって活発に開発・推進されていること、そしてSean Corfield氏のような影響力のあるコミュニティメンバーや企業がCLIへの移行を主導していることからも裏付けられています。

これは、Leiningenが「死んだ」ことを意味するわけではありません。Leiningenは依然として安定しており、機能的で、特に既存のライブラリやシンプルなプロジェクトにとっては完璧に有効なツールです。多くのプロジェクトが「ただ動く」Leiningenを使い続けるでしょう。

しかし、未来はClojure CLIエコシステムにあります。新規プロジェクトを開始する開発者、そしてClojure言語自体の進化と歩調を合わせたい開発者にとって、推奨される道は明らかにClojure CLIです。それは、単に新しいツールセットであるだけでなく、Clojureの核となる哲学を体現した、より表現力豊かで強力な開発体験への入り口なのです。